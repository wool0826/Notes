# 5장. 인덱스

## 1. 쿼리 성능에 관하여

HDD -> SSD 로 저장공간이 변경되면서 데이터를 읽어오는 속도가 현저히 향상됐다.
하지만 innoDB와 같이 버퍼를 사용하는 경우, 실제 DBMS의 성능에는 엄청난 영향을 주지 못하는 것으로 보인다.

[Naver D2 - SSD를 쓰면 DBMS가 빨라질까?](https://d2.naver.com/helloworld/7005)

### 랜덤 I/O 와 순차 I/O

랜덤 I/O는 데이터가 저장될 공간으로 이동하기 위해 디스크 헤더를 자주 움직여야 한다.
**쿼리 튜닝은 랜덤 I/O를 줄여서 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미**한다.

- 예시
    - 인덱스 레인지 스캔 (랜덤 I/O)
        - range 스캔이라 순차 I/O일 것 같지만, 인덱스를 통해 **실제 데이터를 읽을 때는 랜덤 I/O** 이다.
    - 풀 테이블 스캔 (순차 I/O)

위 예시를 보게 되면, 경우에 따라 **풀 테이블 스캔** 이 **인덱스를 통한 스캔** 보다 빠를 수도 있다!!
실제로 옵티마이저가 판단하여, 처리해야하는 데이터가 차지하는 비율이 높아지면 풀 테이블 스캔으로 처리하는 경우가 있다.

## 2. 인덱스란?

관심있는 컬럼을 기준으로 **정렬된 데이터 및 레코드 주소**를 제공하여 조회 시 원하는 데이터에 빠르게 접근할 수 있게 한다.
**데이터를 생성/갱신하는 작업**마다 **인덱스를 수정**해야하므로, **쓰기 성능을 희생하여 읽기 성능을 끌어올리는 기능**

### 인덱스를 생성하면 좋을 기준?

1. 특정 컬럼에 중복된 값이 적을수록 좋다. (카디널리티가 높을 수록 좋다)
    - 성별 (남/여) 컬럼 보다 학번/주민번호 (고유) 컬럼이 인덱스에 더 적합하다.
2. where 조건으로 조회되는 레코드의 개수가 적을 수록 좋다. (선택도가 낮을수록 좋다)

### 인덱스의 역할로 구분

- Primary Index
    - 해당 레코드를 대표하는 컬럼의 값을 기준으로 만들어진 인덱스
    - 꼭 PK만을 기준으로 만드는 것은 아니다.
    - 테이블 마다 **Primary Index는 유일**하다.
- Secondary Index
    - Primary Index를 제외한 인덱스

### 데이터의 중복 허용 여부로 구분

- Unique Index
    - 해당 인덱스에서 **=(equal) 조건**은 1건을 찾으면 더 이상 처리하지 않아도 되기 때문에, 쿼리를 처리하는 방식이 달라진다.
    - 옵티마이저에 영향을 많이 준다고 한다.
- Non-Unique Index

## 3. B(Balanced)-Tree 인덱스

**루트 노드 - 브랜치 노드 - 리프 노드** 로 구성되어 있다.

일반적으로는 인덱스가 정렬되어있어도 실제 디스크에는 임의의 순서대로 저장되어있다.
**InnoDB는 PK 기준으로는 클러스터되어 저장되므로, 순차 I/O로 조회할 수 있다!**

### B-Tree 인덱스 추가 및 삭제

**"Balanced"** Tree 이므로 키를 추가할 때 추가적인 절차가 필요하다.

InnoDB 의 경우, Change Buffer를 이용하여 인덱스의 변경사항을 바로 디스크에 반영하지 않아서 성능 최적화를 진행한다.

#### 인덱스 키 추가

> 일반적인 INSERT의 비용이 1일 때, B-Tree 인덱스 추가 비용은 **1 ~ 1.5**

1. 리프 노드까지 탐색하여 적절한 위치에 인덱스 키를 삽입한다.
2. 해당 페이지가 꽉 찬 경우, 페이지를 분할하여 상위 노드에 반영해야 한다. **(비싼 연산)**

#### 인덱스 키 삭제

간단히 삭제되었음을 마킹하고, 해당 공간을 재활용한다.

#### 인덱스 키 변경

삭제 후 새로 추가하는 방식으로 진행한다.

#### 인덱스 키 검색

- **100% 일치** 또는 **값의 앞부분 (Left-most part)만 일치하는 경우**에 인덱스를 활용할 수 있다.
- 인덱스 키 값이 모종의 사유로 변경된 경우, 인덱스를 활용할 수 없다.


## 4. B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔

#### 처리 방식

인덱스의 범위가 결정됐을 때 사용된다.
리프노드의 시작지점을 판단한 뒤, 조회조건에 맞는 데이터를 모두 조회할 때까지 **인덱스를 순차적으로 스캔**한다.

#### 특징

- 인덱스 레인지 스캔을 통해 조회된 결과는 추가적인 처리를 하지 않아도 **인덱스를 구성하는 컬럼을 기준으로 정렬**되어있다.
- **디스크로부터 데이터를 읽어오는 과정에서 랜덤 I/O**가 일어나므로, 조회되는 데이터가 많아지면 풀 테이블 스캔이 성능이 더 좋다.

인덱스를 통해 **읽어야 할 데이터 레코드가 20% ~ 25% 를 넘으면** 인덱스를 통한 읽기보다 **테이블의 데이터를 직접 읽는 것이 효율적**인 처리방식이 된다.

### 인덱스 풀 스캔
> 인덱스 풀 스캔을 쓰는 건 "인덱스를 효율적으로 사용하지 못한다" 고 말한다

#### 처리 방식

인덱스의 리프노드 제일 처음부터 끝까지 모두 스캔하는 방식

**쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우**
e.g) (A, B, C) 인덱스가 있을 때 Where 조건이 (B,C) 인 경우

#### 특징

인덱스의 크기는 일반적으로 테이블의 크기보다 작으므로, 테이블을 읽는 것보다는 효율적이다.

쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우만 사용된다.
랜덤 I/O 가 엄청 늘어나기 때문에 **인덱스 컬럼을 제외한 컬럼을 조회하는 경우는 절대 사용되지 않는다**

### 루스 인덱스 스캔

#### 처리 방식

오라클의 인덱스 스킵 스캔과 유사한 동작을 하는 방식
**필요하지 않은 키 값은 SKIP 하고 다음으로 넘어가는 형태**

#### 특징

**GROUP BY 나 MAX() / MIN() 함수를 최적화**하는데에 사용된다.
정렬이 되어있기때문에 다 읽지 않아도 MAX / MIN 값은 판별할 수 있다.

## 5. 다중 컬럼 인덱스 / 6. B-Tree 인덱스의 정렬 및 스캔 방향

(A, B, C) 인덱스가 있다면 ORDER BY **A** ASC, **B** ASC, **C** ASC 순으로 정렬한다 (MySQL 스펙 상 컬럼마다 ASC/DESC는 하나로 고정)

즉, ORDER BY A ASC, **B DESC** 와 같은 조건은 **추가적으로 정렬이 필요해지므로 성능에 좋지 않다.**
이러한 경우는, B를 ASC 로 정렬할 수 있도록 설계하거나, 값을 보정하는 작업을 하면 성능을 향상시킬 수 있다.

스캔 방향은 옵티마이저가 최적의 방향을 선택하여 읽는다.

## 6. B-Tree 인덱스의 가용성과 효율성

### 관련 용어

- **작업범위 조건**
    - 작업의 범위를 좁히는데 사용되는 조건
    - 실제 **쿼리의 성능에 영향**을 미치는 조건
- 필터링 조건
    - 결정된 작업의 범위 내에서, 필요한 값인지 확인하는 조건

### 인덱스를 사용 시 주의할 점

- 어떤 컬럼을 먼저 사용하느냐에 따라 **인덱스 효율이 달라진다**
    - 인덱스 컬럼 순서에 맞게 조회조건으로 사용해야, 작업범위조건을 줄일 수 있다.
- 작업범위 조건을 사용하여 **범위를 최소한으로 줄여야** I/O가 줄어든다
- B-Tree는 기본적으로 LeftMost 정렬 (문자열의 경우 읽는 순서대로, 인덱스의 경우 컬럼 순서대로) 이다.
    - 따라서, 문자열의 경우 Prefix가 있어야 성능이 좋다 (LIKE 'AAA%')

### 작업범위 조건으로 사용할 수 없는 조회 조건들

#### 단일 컬럼인 경우

1. <>, NOT IN, IS NOT NULL 등, **NOT-EQUAL 비교**
2. %AA, _AA, %A% 등 **문자열패턴의 뒷부분이 일치해야하는 경우**
3. **인덱스 컬럼이 변경**되어 비교되는 경우 SUBSTRING(A,1,1) = 1
4. **타입**이 서로 다른 비교
5. 문자열 데이터 타입의 **collation**이 다른 경우

> NULL 도 인덱스를 활용할 수 있다.

#### 다중 컬럼인 경우

~~~
INDEX ix_test (column_1, column_2, column_3, ..., column_n)
~~~

##### 작업 범위 조건으로 인덱스를 사용할 수 없는 경우

1. column_1 에 대한 조건이 없는 경우
2. column_1 에 대한 조건이 작업범위조건으로 사용할 수 없는 조건인 경우

##### 작업 범위 조건으로 인덱스를 사용하는 경우

1. column_1 ~ column_(i-1) 까지 Equal(=, IN) 형태로 비교하고 column_i는 Equal(=, IN), >, <, 좌측일치패턴으로 비교하는 경우

## 7. 클러스터링 인덱스

InnoDB에서 클러스터링 인덱스 기능을 지원
**PK 값이 비슷한 레코드끼리 묶어서 디스크에 저장하는 것**을 "클러스터링 인덱스"라고 표현한다.

B-Tree 기반 인덱스와 달리, **리프노드에 모든 컬럼**이 같이 저장된다.

- PK가 없는 경우
    1. NOT NULL 옵션의 UNIQUE INDEX 중에 첫 번째 인덱스를 클러스터 키로 선택
    2. 자동으로 유일한 값을 가지도록 증가되는 컬럼을 내부적으로 처리하여 관리

이 기능을 기반으로 **InnoDB는 PK 기반 조회를 빠르게 처리**할 수 있다. (PK 범위 검색의 경우 매우빠름)

**BUT**

모든 보조인덱스로 조회할 때, PK를 조회한 후 **다시 레코드를 조회**해야하므로 처리속도가 조금 느려진다.
INSERT할 때, **PK 기반으로 디스크에 저장될 위치를 찾아야 하므로**, 처리성능이 느리다.


## 8. 유니크 인덱스

유니크 인덱스는 생각외로 성능 상 이점이 많지 않다.

- 읽기
    - 유니크 인덱스가 지표 상으로 빨라보이는 이유는 1건만 읽으면 되기 때문이다.
    - 보조인덱스는 여러 건 읽는다.
- 쓰기
    - 유니크 인덱스는 “중복확인”을 무조건 해야하므로 **1단계 더 처리해야한다**
    - 중복된 값을 체크할 때 읽기잠금 / 쓸 때 쓰기잠금으로 인해 **데드락에 많이 빠진다**
    - InnoDB의 경우, 유일성 조건으로 인해 메모리에 쓰는 것이 아니라 무조건 **디스크에 접근**해야하므로 성능 상 불리하다.