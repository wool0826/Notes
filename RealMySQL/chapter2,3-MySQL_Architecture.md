# 2장. 설치

#### 글로벌 범위의 시스템 변수

하나의 MySQL 서버 인스턴스에서 전체적으로 영향을 미치는 시스템 변수
대표적으로 쿼리 캐시의 크기(query_cache_size), MyISAM의 키 캐시 크기(key_buffer_size), InnoDB의 버퍼 풀 크기(innodb_buffer_pool_size)가 있다.

#### 세션 범위의 시스템 변수

MySQL 클라이언트가 서버에 접속할 때 기본적으로 부여하는 옵션의 기본값을 제어하는 데 사용
대표적으로 AutoCommit 변수

#### my.cnf 설정

- event-scheduler
- sysdate-is-now: sysdate()와 now()는 동작이 다르다.
    - sysdate: 쿼리에서도 여러 번 호출되었을 때 결과가 다 다르다.
    - now: 한 쿼리 내에서는 여러 번 호출되어도 동일한 결과를 낸다.
- max_connections
- thread_cache_size: 스레드풀에 얼마나 보관할 지
    - 커넥션은 클라이언트와 서버와의 연결 그 자체를 의미
    - 스레드는 해당 커넥션으로부터 오는 작업요청을 처리하는 주체
- wait_timeout
    - 클라이언트가 wait_timeout에 지정된 시간동안 아무런 요청없이 대기하는 경우 커넥션을 강제로 종료
    - 기본은 8시간
- transaction-isolation
    - 기본 격리 수준은 REPEATABLE READ

# 3장. 아키텍쳐

- 비중 높음
    - MySQL 아키텍처
    - InnoDB 스토리지 엔진 아키텍처
    - NDB 클러스터 스토리지 엔진 (분산 DB)
    - MySQL 로그 파일
- 비중 낮음
    - MyISAM 스토리지 엔진 아키텍처
    - MEMORY 스토리지 엔진 아키텍처
    - TOKUDB 스토리지 엔진
    - 전문 검색 엔진

## 3-1. MySQL 아키텍처

### 3.1.1 MySQL 전체 구조

![Screen Shot 2021-07-12 at 9.09.08 PM.png](/files/0a7056be-7a5f-1279-817a-9a9f3f397321)

#### MySQL 엔진

MySQL 서버의 머리역할에 해당하는 엔진

- 커넥션 핸들러 - 클라이언트의 접속 및 쿼리 요청을 처리
- SQL 파서 및 전처리기 - 클라이언트가 전송한 쿼리가 적절한 쿼리인지 판단
- **옵티마이저** - 전달받은 쿼리를 최적화하는 작업을 수행
- 최적화를 위한 MyISAM의 키 캐시 or InnoDB의 버퍼 풀 관리

> 이 책에서 이야기하고자 하는 내용은 대부분 옵티마이저가 선택하는 내용을 설명하는 것
> 어떻게 하면 옵티마이저가 더 나은 선택을 할 수 있게 유도하는 가를 알려주는 것

#### 스토리지 엔진

MySQL 엔진에서 처리된 내용을 통해 **어떻게 데이터를 디스크 스토리지에 저장/읽어올지 계산** 하는 엔진
각 테이블마다 다른 엔진을 사용할 수 있다

#### 핸들러 API

MySQL 엔진에서 데이터를 쓰거나 읽어야할 때, 요청을 받아서 스토리지 엔진에 요청할 때 사용되는 API

> 이런 구조인 이유가 책에 나오지는 않으나, **Facade 패턴**처럼 사용하기 위해 인 것으로 개인적으로 생각됩니다.

### 3.1.2 스레딩 구조

![Screen Shot 2021-07-12 at 9.09.02 PM.png](/files/0a7056be-7a5f-1279-817a-9a9f3eeb731d)

- 포어그라운드 스레드
    - 사용자의 요청을 처리합니다 **(Threadpool 로 관리됨)**
        - 캐시에 있으면 캐시를 바로 반환하고, 없으면 실제 데이터를 읽는 처리를 하여 캐시에 저장합니다
    - 포어그라운드 스레드의 총 개수는 **thread_cache_size**에 의해 관리됩니다
- 백그라운드 스레드 (InnoDB의 경우)
    - 사용자의 요청을 처리한 결과를 **스토리지에 쓰거나, 로그를 작성**하는 요청을 처리합니다
        - 인서트 버퍼를 병합
        - 로그를 디스크로 기록
        - 버퍼 풀의 데이터를 디스크에 기록
        - 데이터를 버퍼로 읽음
        - 잠금이나 데드락을 모니터링
        - 모든 스레드를 총괄

상용 DB 대부분 **INSERT 작업을 버퍼링을 통해 일괄처리하는 기능**이 탑재되어있다.

### 3.1.3 메모리 할당 및 사용 구조

![Screen Shot 2021-07-12 at 9.21.33 PM.png](/files/0a7056be-7a5f-1279-817a-9aaa71d70aa1)

- 글로벌 메모리 영역
    - 일반적으로 MySQL 서버에 하나의 메모리 공간만 할당
- 로컬(세션) 메모리 영역
    - 클라이언트가 커넥션을 생성할 때마다 할당되는 메모리 공간
    - 해당 메모리 영역은 공유되어 사용되지 않음
        - Read 버퍼
        - 랜덤 Read 버퍼
        - 커넥션이 열려있는 동안 계속 할당된 상태인 공간
            - 커넥션 버퍼
            - Result 버퍼
        - 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간
            - 조인 버퍼
            - 정렬 버퍼

### 3.1.4 플러그인 스토리지 엔진 모델

MySQL의 독특한 구조, 플러그인을 쉽게 추가/삭제가 가능한 구조

모든 작업은 **Handler API를 통해 처리**해야한다.
스토리지 엔진은 **데이터 읽기/쓰기** 영역의 처리만 차이가 있을 뿐이다. 실제로 복잡한 GroupBy / OrderBy 구문들은 **쿼리 실행기**에서 처리된다.

> 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 어떤 영역에서 처리되는지 구분할 줄 알아야 한다.

### 3.1.5 쿼리 실행 구조 / 3.1.7 쿼리 캐시

![Screen Shot 2021-07-12 at 9.30.53 PM.png](/files/0a7056be-7a5f-1279-817a-9ab3440d1aa2)

- 쿼리 파서
    - 쿼리를 Tree 형식으로 파싱, **문법적인 오류를 판단**할 수 있다.
- 전처리기
    - 파서 트리를 기반으로 쿼리 문장에 **구조적인 문제점이 있는지 판단**
    - 접근권한, 객체의 존재여부 판단
- 옵티마이저
    - 사용자의 요청을 **저렴한 비용으로 가장 빠르게 처리할 수 있도록 판단**하는 역할
- 쿼리 실행기
    - **옵티마이저에 의해 결정된 계획대로 핸들러에게 요청**하는 역할
- 스토리지 엔진(핸들러)
    - 데이터를 **읽고 쓰는 역할**

#### 쿼리 캐싱

**Map< 쿼리 문장 , 쿼리 결과 >** 로 캐싱을 처리합니다.
캐시 히트율과 실제 성능개선정도는 큰 관련이 없다. (무거운 쿼리를 캐시했다면 1%도 효과적)

1. 요청된 쿼리 문장이 **쿼리 캐시에 존재**하는가?
    - 공백이나 탭, 대소문자까지 동일해야함.
2. 해당 사용자가 그 결과를 **볼 수 있는 권한**을 가지고 있는가?
3. 트랜잭션 내에서 실행된 쿼리인 경우, 그 결과가 **가시 범위 내의 트랜잭션**에서 만들어진 결과인가? (InnoDB)
    - 현재 트랜잭션보다 먼저 처리된 트랜잭션의 데이터인 경우 가시범위 내
4. 쿼리에 사용된 기능이 캐시돼도 **동일한 결과를 보장**할 수 있는가?
    - CURRENT_DATE, SYSDATE, RAND, **NOT DETERMINISTIC** 등의 함수는 동일한 결과를 보장 X
    - Preparestatement 의 경우 변수가 결과에 영향을 미치지 않는가?
6. 캐시가 만들어지고 난 이후 해당 데이터가 **다른 사용자에 의해 변경**되지 않았는가?
    - 캐시 무효화작업은 레코드 단위가 아니라 테이블 단위로 처리 -> 성능에 영향을 주므로 크기를 적절히 32M ~ 64M로 설정
7. 쿼리에 의해 만들어진 결과가 **캐시하기에 너무 크지 않은가**?
8. 그 밖에도 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?
    - 임시테이블에 대한 쿼리
    - 사용자 변수의 사용
    - 컬럼 기반의 권한 설정
    - LOCK IN SHARE MODE 힌트 (락)
    - FOR UPDATE 힌트 (락)
    - User Defined Function의 사용
    - 독립적인 SELECT 문장이 아닌 **일부분의 서브 쿼리**
    - 스토어드 루틴에서 사용된 쿼리
    - SQL_NO_CACHE 힌트

### 3.1.6 복제

2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술

- 마스터
    - MySQL의 **바이너리 로그**가 활성화되면 마스터가 될 수 있다.
    - 마스터 서버에서 실행되는 DML, DDL 가운데 **데이터의 구조나 내용을 변경하는 모든 쿼리 문장**은 바이너리 쿼리에 기록
    - **슬레이브 서버에서 변경내역을 요청**하면 마스터는 해당 바이너리 로그를 읽어 슬레이브로 넘긴다
- 슬레이브
    - 일반적으로 Read-Only DB로 구성
    - 마스터의 **바이너리 로그를 토대로 릴레이 로그를 구성**하고 릴레이 로그를 **재실행(replay)** 한다


## 3.2 InnoDB 스토리지 엔진 아키텍처

MySQL 스토리지 엔진 중 거의 **유일하게 레코드 기반의 잠금**을 제공
높은 동시성 처리 / 안정적이며 성능 우수

Memory 스토리지 엔진과 비교해도, 동시성에서 엄청난 우위를 보임
(Memory 엔진은 테이블 기반 락을 잡기 때문) - 메모리만 충분하다면 Memory 스토리지 엔진보다 좋음

![Screen Shot 2021-07-12 at 9.54.34 PM.png](/files/0a7056be-7a5f-1279-817a-9ac8d13f1bfe)

### InnoDB 특징

- PK에 의한 클러스터링
    - PK 값의 순서대로 디스크에 저장 (Ckey 가 같은 디스크 내에서 처리되는 느낌?)
    - **Range Scan**에서 강점을 보임
- 자동 데드락 감지
    - 데드락 감지 시 **롤백이 가장 용이한 트랜잭션(레코드를 가장 적게 변경)을 강제종료**
- 자동화된 장애 복구
- 오라클의 아키텍처 적용

### 3.2.2 InnoDB 버퍼 풀

**디스크에 쓰기 전까지의 대부분의 처리가 진행**되는 공간. INSERT, UPDATE, DELETE 등의 처리가 진행된다.
디스크에 기록되지 않은 변경된 데이터(Dirty Data)를 가지고 있고, 주기적으로 디스크로 기록한다.

> 이렇게 메모리에 쓰면 ACID 를 어떻게 보장하지?? -> Redo 로그를 통해 보장한다.

### 3.2.3 Undo 로그

UPDATE, DELETE로 인해 **변경되기 전의 데이터**를 보관
이전 트랜잭션이 커밋된다고 **바로 삭제되지는 않는다** (MVCC)

1. 트랜잭션의 롤백 대비용
2. 트랜잭션 격리수준을 유지하면서 동시성을 높이는 용도

### 3.2.4 인서트 버퍼 (Change Buffer)

INSERT, UPDATE, DELETE 될 때 **데이터 + 인덱스가 변경**되어야 하므로, 디스크에 매 번 작업하는 건 비효율적이므로 버퍼링한다

- 작동 조건
    - **secondary non-unique index**에만 작동
        - unique index의 경우, 머지가 되지 않으면 **유일성판단**이 안 되므로
    - **변경작업에 해당하는 page가 buffer pool에 존재하지 않을때**만 change buffer에 변경을 저장한다.
- 머지가 발생하는 경우
    - **캐시된 인덱스에 관련된 read operation**이 발생해 **buffer pool에 로드**된 경우
        - change buffer에 캐시되어있는 인덱스를 buffer pool에 불려진 페이지에 **병합처리**한다.
        - buffer pool에 병합된 인덱스는 **설정된 flush 조건에 의해 DB에 기록**된다.
    - I/O가 놀고 있을 때
    - 종료요청을 받은 경우

### 3.2.5 Redo 로그 및 로그 버퍼

**ACID를 보장**하는 기능

데이터를 변경하고 커밋하면 원래라면 즉시 디스크에 작성해야하지만, 성능이 좋지 못함.
InnoDB와 같이 버퍼 풀을 따로 둬서 성능을 끌어올리지만 ACID 보장은 X

**Redo 로그** 파일을 따로 작성하여, 순차적으로 디스크에 쓰는 작업을 진행한다.

### 3.2.6 MVCC / 3.2.7 잠금없는 일관된 읽기

> 트랜잭션 관련해서는 https://yobi.navercorp.com/platform-labs-jr-study/posts/68?referrerId=1040932396 이 게시물에 정리했었습니다.

MVCC를 이용해 **락을 걸지 않고 읽기 작업을 수행**한다. (SERIALIZABLE 격리수준은 제외)
**Undo 로그**를 통해서 Multi Version (특정 레코드의 다양한 버전의 데이터) 을 관리할 수 있다.

트랜잭션이 길어지고, 여러 개가 되면 Version이 늘어날 수 있다.
- 트랜잭션이 객체를 볼 수 있는 조건
    - txId를 기준으로 나보다 늦게 시작한 트랜잭션의 값들은 무시한다.
    - 현재진행형인 트랜잭션의 값은 무시한다.
    - 어보트된 트랜잭션의 값은 무시한다.


~~~sql
INSERT INTO company(id, name, area) VALUES (1, '네이버', '분당');
COMMIT;

-- UPDATE는 COMMIT 하지 않은 상태
UPDATE company SET area='강남' WHERE id=1;
~~~

![Screen Shot 2021-07-13 at 9.28.07 PM.png](/files/0a705587-7a60-1e77-817a-9fd6d3915090)

~~~sql
-- 다른 사용자가 해당 쿼리를 실행하면 어떤 데이터를 조회해야할까?
SELECT * FROM company WHERE id=1;
~~~

- READ_**UNCOMMITTED**
    - **커밋되지 않은 데이터**인 '분당'을 읽는다.
- READ_**COMMITED**, REPEATABLE_READ, SERIALIZABLE
    - **이전에 커밋된 데이터**인 '강남'을 읽는다.



## 3.5 NDB(Network Database) 클러스터 스토리지 엔진

**네트워크를 통해 데이터 분산을 지원**하는 스토리지 엔진
**가용성에 집중**된 스토리지 엔진

### 3.5.1 특성

- **무공유 클러스터링**
    - 하나의 스토리지가 작동을 멈춰도 서비스에 영향을 미치지 않는다.
- **메모리** 기반
    - 클러스터 노드간의 **빠른 데이터 동기화**를 위해 속도가 빠른 메모리를 사용
    - **주기적으로 디스크로 데이터를 기록**하여, 불가피한 상황 (정전 등)에 대비한다. (InnoDB의 Redo 로그같이)
- 자동화된 Fail Over
    - **모든 구성노드가 서로를 Health Check**하여 문제가 발생해도 다른 노드가 바로 역할을 이어받는다.
- 동기방식(sync) 으로 복제
    - 노드가 전담하는 파티션(Primary Partition) / 백업 위주의 보조 파티션(Secondary Partition)을 구성
    - 동기방식의 의미는 **"모든 노드에 데이터가 복제되어야 해당 트랜잭션이 끝난 것"**
- 온라인 스키마 변경
    - DML과 DDL을 동시에 처리할 수 있다;;

### 3.5.2 아키텍처

관리노드 / 데이터 노드 / SQL 노드로 구성
SPoF를 방지하기 위해 모두 이중화될 수 있도록 구현

![Screen Shot 2021-07-13 at 10.02.49 PM.png](/files/0a705587-7a60-1e77-817a-9ff69ab66837)


- 관리 노드
    - 이름 그대로 관리자의 역할을 하는 노드
    - 각 노드에게 새로운 노드 추가, 장애, 기타 정보들을 **Broadcasting 하는 역할**
- 데이터 노드
    - 데이터를 저장하는 **스토리지를 관리** / SQL 노드에서 오는 DML 요청을 모두 처리
    - PK 기준으로 파티셔닝되어 각 데이터노드에서 관리
- SQL 노드 / API 노드
    - MySQL 에서 **Handler API** 와 유사한 역할
    - 사용자의 요청을 받아서 데이터 노드에 전달하고, 결과를 반환한다.

#### 파티션 관리 방법 (노드간 데이터 구성 방식)

노드 그룹 / 파티션은 사용자가 설정할 수 없고, 자동으로 계산된다.
레플리카는 (1, 2)로 설정할 수 있으나, 1은 가용성의 의미가 없으므로 2만 사용된다고 보면 된다.

각 노드는 Primary Partition / Secondary Partition 으로 나눠서 관리한다.

![Screen Shot 2021-07-13 at 10.09.06 PM.png](/files/0a705587-7a60-1e77-817a-9ffc524568b0)

#### 클러스터 간 복제 구성 방식

MySQL의 복제기능을 활용하여 클러스터 간 복제를 구현한다.
각 클러스터마다 변경된 데이터를 받아서 병합해주는 **"Binlog Injector Thread"** 를 별도로 구성한다.


## 3.6 TOKUDB 스토리지 엔진

- B-Tree
    - 현재 DBMS의 인덱스 알고리즘으로 가장 많이 사용되고 가장 범용적인 목적으로 사용되는 인덱싱 알고리즘
    - 새로운 인덱스 값을 저장하려면 많은 비용이 든다.
    - 지속적인 INSERT, DELETE, UPDATE로 인해 인덱스 데이터의 단편화 -> 인덱스 페이지의 충전율(Fill Factor)가 떨어짐 = Index Aging = Range Scan 성능에 영향을 줌
- 프랙탈 트리
    - B-Tree의 단점을 개선해서 나온 인덱싱 알고리즘


## 3.8 MySQL 로그 파일

MySQL은 모니터링관련한 툴이 부족하여 로그로 대체해야 한다.

### 3.8.3 슬로우 쿼리 로그

![Screen Shot 2021-07-13 at 10.18.04 PM.png](/files/0a705587-7a60-1e77-817a-a004892d6b81)

Query_time - 실제 쿼리가 실행되는데 걸린 전체 시간
Lock_time - 잠금을 처리하는데 걸린 시간 (대기시간 + 잠금자체를 처리하는 코드 처리시간)
Rows_examined - 해당 쿼리를 위해 몇 건의 레코드에 접근했는지
Rows_sent - 실제 몇 건의 결과를 클라이언트로 보냈는지

해당 요소들을 통해서 어떤 부분을 튜닝하면 좋을지 판단할 수 있다