## 요약

1. 통합테스트에서는 전체 분기를 대부분 테스트하는 happy case, 예외들을 테스트하는 edge case를 주로 테스트하자.
2. 외부의존성에서 격리된 의존성들은 테스트에서 사용하고, 격리되지 않은 의존성들은 mocking 한다.
3. 도메인 모델을 잘 격리하고 순환의존성을 제거하여 도메인 모델마다의 경계를 명확히 하고, 계층 수를 줄여서 서비스를 파악하는데 쉽게 한다.
4. 통합테스트에서는 외부의존성의 관리가 힘든 경우 다중 실행 구절을불가피하게 사용할 수 있다.
5. 로깅에서는 도메인에 밀접한 연관이 있는 로그는 테스트할 수 있다.

### 8.1 통합테스트는 무엇인가?

단위 테스트가 아닌 테스트. 시스템이 프로세스 외부 의존성과 통합해 어떻게 동작하는지를 검증. (프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인)

- 단위 테스트 3요소
  - 단일 동작 단위를 검증
  - 빠르게 수행
  - 다른 테스트와 별도로 처리

통합테스트는 단위테스트보다 더 많은 코드를 거치기 때문에, 회귀방지에서 우수하다.
제품 코드와의 결합도도 낮기때문에 리팩터링 내성도 우수하다.

> 단위테스트로 가능한 한 많이 비즈니스 시나리오의 예외상황을 테스트
> 통합테스트는 happy case, edge case 를 다룬다.

#### 통합테스트는 어떻게 구성해야하는지?

통합테스트에서 외부 의존성과의 상호 작용을 확인해야하므로, 모든 외부 의존성을 사용하는 흐름을 선택 (쉽게 말하면 모든 if 분기를 태울 수 있는 복잡한 테스트 케이스)
모든 외부 의존성에 대한 테스트를 수행할 수 있도록 테스트를 구성

#### 테스트의 책임

canExecute 패턴의 경우, 저번 주에 상세히 설명해주셨듯이 테스트의 책임이 검증하는 클래스가 가지게 되므로 통합테스트에서는 테스트할 충분한 가치가 없다. 고 표현하고 있습니다.

이렇게 통합테스트에서도 "할 수는" 있으나 단위 테스트가 더 가볍기 때문에 단위 테스트로 구현하는 것이 더 적절하고, 더 버그를 빨리 확인할 수 있다.

#### 빠른 실패 원칙

예기치 않은 오류가 발생한다면 해당 지점에서 더 이상의 로직을 수행하지 않도록 코드를 구성한다. 이 원칙을 통해 애플리케이션의 안정성을 높일 수 있다.

> 버그를 빨리 발견할수록 더 쉽게 해결할 수 있다.
> 버그는 애플리케이션의 상태를 손상시킨다. 손상된 상태가 DB에 침투하면 고치기가 훨씬 어려워진다. 이를 방지할 수 있다.

### 8.2 어떤 프로세스 외부 의존성을 테스트해야하는가?

> 외부 클라이언트는 데이터베이스를 어떻게 구성하는지 신경 쓰지 않는다.
> 중요한 것은 시스템의 최종 상태다..

저는 이렇게 저만의 용어로 이해하였는데요.

- 격리된 외부 의존성 (책에서는 관리 의존성)
  - 외부와 격리되었으므로, 이 의존성은 "마음대로" 관리해도 된다.
  - 즉, 실제 인스턴스를 사용해도 외부로 영향을 전파하지 않는다.
- 격리되지 않은 외부 의존성 (책에서는 비관리 의존성)
  - 외부와 격리되지 않았으므로, 잘못 사용하게되면 외부로 오류가 전파될 수 있다.

실제 포인트를 예로 들면, `nm_rwdpnt_trad`는 격리된 의존성이라고 볼 수 있을 것 같습니다.
왜냐하면 모든 nm_cash_trad와 관련된 데이터는 저희 쪽 API를 통해서 외부로 나가기 때문입니다.

#### 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기

`NM_NVPNT_TRAD_CDC 테이블`의 경우, nm_rwdpnt_trad 와 달리 격리되지 않은 외부 의존성이라고 생각합니다.
실제 결제형에서도 사용하지만, 저희 쪽에서 해당 테이블을 참조하고 있기 때문에 컬럼을 변경했을 때, 저희 쪽에서도 영향을 받을 수 있기 때문입니다. (대부분 배치라 영향이 적을 뿐인 것 같습니다.)

책에서도 이런 테이블에 대한 사례를 소개하고 있고, 이러한 경우 **동기/비동기 통신을 통해 데이터를 주고 받는 것을 권장하는 것 같습니다.**
=> 여러 서비스에서 공유되다보면 쉽사리 수정을 할 수 없는 상태가 되어버린다.

> 이러한 테이블은 사실상 메시지 버스 역할을 하고, 각 행이 메시지 역할을 한다.

#### 불필요한 테스트는 없는 것보다 나쁘다.

Mock으로 대체할 수 없는 의존성이 있는 경우, 아예 테스트를 작성하지 않고 도메인 모델의 단위 테스트에 집중할 것을 권장합니다.

- 관리 의존성을 Mock으로 대체하면 리팩터링 내성이 저하된다.
- 관리 의존성을 Mock으로 대체하면 회귀 방지도 떨어진다. (실제 코드를 수행하지 않으므로)

### 8.3 CRM 테스트를 예시로 한 통합테스트 작성 방식

가장 일반적인 지침은 "1.가장 긴 주요흐름 과 2.단위 테스트로는 수행할 수 없는 모든 예외 상황을 다루는 것"

```csharp
[Fact]
public void Changing_email_from_corporate_to_non_corporate() {
    // given
    var db = new Database(ConnectionString);

    User user = CreateUser("user@mycorp.com", UserType.Employee, db);
    CreateCompany("mycorp.com", 1, db);

    var messageBusMock = new Mock<IMessageBus>();
    var sut = new UserController(db, messageBusMock,Object);

    // when
    string result = sut.ChangeEmail(user.UserId);

    // then
    Assert.Equal("OK", result);

    object[] userData = db.GetUserById(user.UserId);
    User userFromDb = UserFactory.Create(userData);

    Assert.Equal("new@gmail.com", userFromDb.Email);
    Assert.Equal(UserType.Customer, userFromDb.Type);

    object[] companyData = db.GetCompany();
    Company companyFromDb = CompanyFactory.Create(companyData);

    Assert.Equal(0, companyFromDb.NumberOfEmployees);

    messageBusMock.Verify(
        x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"),
        Times.Once
    );
}
```

### 8.4 인터페이스 활용 방식에 대한 의문 제기

> 코드를 작성하는 것은 문제를 해결하는 값비싼 방법이다. [재밌게 봤던 영상](https://www.youtube.com/watch?v=3H4umWD5bwI)

인터페이스를 다음과 같은 이유로 사용합니다.

- 프로세스 외부 의존성을 추상화해서 느슨한 결합을 달성하기 위해
- 기존 코드를 변경하지 않고 새로운 기능을 추가해서 공개폐쇄원칙을 지키기 위해

책에서는 특정 상황에서는 해당 이유가 오해라고 설명하고 있습니다.

- `단일 구현을 위한 인터페이스`는 추상화가 아니고, 결합도도 느슨해지지 않는다.
  추상화되기 위해서는 최소한 두 가지의 구현은 있어야 한다.
- YAGNI를 위반하기 때문에 잘못된 생각이다.
  You aren't gonna need it. "현재 필요하지 않은 기능에 시간을 들이지 말라"
  코드는 적을수록 관리하기 좋다. 만약을 위해 코드를 작성하게 되면, 코드베이스를 유지하는 비용이 추가적으로 더 들게 된다.

#### 그렇다면 왜 인터페이스를 쓰는가?

저자는 간단히 말해 "쉽게 Mocking 할 수 있기 때문" 이라고 말하고 있습니다.
즉, 테스트 대역이 필요없다면 굳이 프로세스 외부 의존성에서 인터페이스를 사용할 필요가 없다고 말합니다.

프로세스 내부 의존성에서의 단일 구현 인터페이스는 가능한 자제할 것을 권장하는 것 같습니다.

### 8.5 통합테스트 모범 사례

- 도메인 모델 경계 명시하기
- 애플리케이션 내 계층 줄이기
- 순환 의존성 제거하기

읽고 든 생각은 "도메인 간의 격리" 와 "계층의 단순화" 를 목표로 삼고 설계해야한다. 인 것으로 이해했습니다.

경계가 명확하지 않다면?
=> 어떤 테스트를 작성해야할지 명확하지 않아지고, 테스트 작성도 어려워진다.

계층이 많아지면?
=> 코드를 해석하기 위해 타고타고 들어가야되므로 해석이 너무 어려워진다. (마일리지 코드 같은 느낌이 계층으로 구현되어 있는 느낌)
=> 각각의 계층을 각각 검증하게 되고, 이렇게 되면 통합 테스트의 의미가 없어진다.

#### 다중 실행 구절의 사용

하나의 테스트는 가능한 하나의 when 구절을 가지도록 합니다.
when 구절이 여러 개여도 처음에는 합리적이라고 판단될 수 있으나, **테스트가 초점을 잃고 순식간에 너무 커질 수 있다는 문제가 있습니다.** (이거 정확히 이해 못 했습니다..)

※ 예외: 원하는 상태로 만들기 어려운 프로세스 외부 의존성으로 작동하는 테스트

> 은행 시스템에서 호출 수를 제한했다거나 하는 경우, 한 번의 호출로 여러 테스트를 수행해야할 수도 있다.

### 8.6 로깅도 테스트해야하는가?

책을 읽으면서 처음으로 인식하게 된 영역입니다.

제가 이해했을 때는

- Support Logging (지원 로깅)
  - 개발자 이외의 인원이 보는 로그 (Access Logging 이라던지, 잔액수정 Step 로그라던지?)
- Diagnostic Logging (진단 로깅)
  - 개발자만 보는 로그 (배치의 정보성 로그들, 시작, 몇 건이 처리되었는지..)

지원로깅은 테스트하고, 진단로깅은 테스트하지 않아도 된다.

#### 테스트한다면 어떻게 할 것인가?

Logger를 지원로깅만 남기는 로거 구현체, 진단로깅만 남기는 로거 구현체로 나누어서 테스트를 용이하게 합니다.
지원로깅만 남기는 로거 구현체만 실제 인스턴스를 사용하여 통합테스트를 구성할 수 있다.

그런데 Logger도 외부 의존성을 가지기 때문에, 도메인 모델에 포함되면 안 된다. (비즈니스 로직과 외부 의존성을 분리해야하는 원칙 위반)
책에서는 이것을 MessageBus를 통해 해결하였습니다.

비즈니스 로직에서는 외부로 어떤 메시지를 보낼지만 전달하고, Controller 에서 해당 메시지를 직접 보내는 작업을 수행합니다.

```csharp
class User {
    public void ChangeEmail(string newEmail, Company company) {
        ...
        AddDomainEvent(new EmailChangeEvent(UserId, newEmail));
    }
}
```

```csharp
class UserController {
    public string ChangeEmail(int userId, string newEmail) {
        ...

        _eventDispatcher.Dispatch(user.DomainEvents);
    }
}
```

이렇게 구현하였을 때, 테스트는 다음과 같이 수행되어야 합니다.

- 단위 테스트로 User 에서 Event를 잘 발행하는지 테스트해야한다.
- 통합 테스트로 UserController 에서 Event를 Dispatch 했을 때 로깅이 잘 호출되는지를 검증해야한다.

#### 로그의 비율

> 핵심은 로그의 신호 대비 잡음 비율이다. 로그가 많을수록 관련 정보를 찾기가 어려워진다. 신호를 최대한으로 늘리고 잡음을 최소한으로 줄여라.

매번 만기님이 말씀하시는 쓸데없는 warn, error 에 대한 이야기인 것 같기도 합니다.
로그가 너무 많다보니 실제로 저희에게 유용한 정보를 찾는데에 불필요한 시간이 사용됩니다.

그리고 과도한 로깅은 코드를 이해하는데에 방해가 되기 때문에, 실제 필요한 로그만 사용하는 것을 책에서도 권장하고 있는 것 같습니다.

#### Ambient Context 안티패턴

도메인 모델에 정적 메소드를 통해 Logger를 처리하고 비공개 정적 필드에 저장하는 패턴

- 의존성이 숨어있게되고, 변경하기 어렵다.
- 테스트가 더 어려워진다.

위와 같은 단점이 있어서 이렇게 사용하지 말고, Logger 관련 의존성을 주입하는 것을 권장하는 것 같습니다.
